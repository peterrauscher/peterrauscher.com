[{"content":"<h1 id=\"howtorankyoursitehigherongoogle\">How to Rank Your Site Higher on Google</h1>\n<p>Are you looking for ways to improve your website's ranking on Google? Ranking high on search engines is <strong>essential</strong> for businesses or content creators to reach their target audience and drive more traffic to their site. I'll say that again, you <em>really</em> need to know who your audience is to effectively follow this guide. Any content that is aimed at too general a population will inevitably be edged out by huge competitors. Niche markets are key here. Anyways, let's get into it!</p>\n<h2 id=\"choosingthebestkeywordsforyourcontent\">Choosing the Best Keywords for Your Content</h2>\n<p>One of the critical components of optimizing your website for search engines is using the right keywords. Start by researching the keywords that your target audience is searching for. There are many keyword research tools available, such as <a href=\"https://backlinko.com/google-keyword-planner\">Google Keyword Planner</a>, <a href=\"https://backlinko.com/hub/seo/semrush\">SEMrush</a>, and <a href=\"https://www.seedkeywords.com\">SeedKeywords.com</a>, which can help you identify the keywords that are relevant to your content, and to your audience.</p>\n<p>Keywords are the main reason why specialziation is SO important. The less competitive your keywords are, the higher you will rank in searches. End of story. If you are targeting a niche that sites with millions of <a href=\"https://en.wikipedia.org/wiki/Backlink\">backlinks</a> are also targeting, you will be hopelessly outclassed unless you manage to drive traffic and backlinks to your site through another source.</p>\n<p>Once you have identified your target keywords, incorporate them strategically into your website's content. Put them in page titles, put them in headings, put them in your <code>&lt;meta&gt;</code> tags, and litter them throughout your body. But the important point here is to make it flow nicely with your content. Don't spam keywords, as this WILL achieve the opposite, and negatively impact your ranking.</p>\n<h2 id=\"buildingbacklinks\">Building Backlinks</h2>\n<p>Backlinks are links from other websites that point to your website. <a href=\"https://www.searchenginejournal.com/google-algorithm-history/\">The first version of Google's algorithm</a> ranked sites only on their number of backlinks - and some savvy scripters quickly abused this to rank their site highest. More advanced methods were made to combat the problem, but Google considers backlinks as a vote of confidence, indicating that other websites consider your content to be relevant and valuable. Building high-quality backlinks is crucial for improving your website's ranking on Google. If your keywords are highly competitive, you need to use backlinks to rank higher.</p>\n<p>There are several ways to build backlinks, including guest blogging, creating valuable content, and participating in forums and communities related to your niche. Finding opportune times to link to your content on various social media platforms will also help (again, <em>don't</em> spam). Be sure to focus on building organic, high-quality backlinks, as spammy or low-quality backlinks can hurt your ranking.</p>\n<h2 id=\"usingattractiveimages\">Using Attractive Images</h2>\n<p>Images can make your website more attractive and engaging, which can help keep visitors on your site longer. Using high-quality, relevant images can also improve your website's ranking on Google.</p>\n<p>When adding images to your website, be sure to optimize them for search engines. Ensure you do the following for each image you're incorporating into your site:</p>\n<ol>\n<li>Use a descriptive filename. Despite popular belief, filenames WILL influence your SEO ranking.</li>\n<li>Add an alt tag. Sites with more accessibility features will be ranked higher on Google. Check out <a href=\"https://khan.github.io/tota11y/\">tota11y</a> if you don't already use it, to optimize your site's accessibility for higher rankings!</li>\n<li>Use high-quality images that follow good stylistic practices, like the rule of thirds. High-resolution, professional shot stock images work great. For copyright-free images, checkout <a href=\"https://unsplash.com/\">Unsplash</a> or <a href=\"https://pixabay.com\">Pixabay</a>.</li>\n</ol>\n<h2 id=\"utilizinggoogleanalytics\">Utilizing Google Analytics</h2>\n<p><a href=\"https://analytics.google.com/analytics/web/\">Google Analytics</a> is a powerful tool that can help you monitor your website's performance and identify areas for improvement. With Google Analytics, you can track your website's traffic, bounce rate, and conversion rates, among other things.</p>\n<p>By analyzing this data, you can identify which parts of your website are performing well and which areas need improvement. Use the information in this guide to optimize the poorly performing pages on your site, and you will start ranking higher. Use these insights to improve your user experience, and a higher Google ranking <strong>will</strong> follow.</p>\n<h2 id=\"wrappingup\">Wrapping Up</h2>\n<p>There's no shortcuts to success here. Ranking your website higher on Google requires market analysis, time, effort, and a sound strategy. But, by choosing the right keywords, building high-quality backlinks through organic means, using compelling imagery, and utilizing Google Analytics, you can improve your website's ranking and drive more traffic to your site. SEO is a never-ending process, and you need to continue to monitor your website's performance and make adjustments as needed.</p>","data":{"title":"How to Rank Your Site Higher on Google","date":"2022-03-31T00:00:00.000Z","published":true},"isEmpty":false,"excerpt":"","filename":"/Users/peterrauscher/Repositories/peterrauscher.com/posts/google-seo.md"},{"content":"<h1 id=\"leveragetailrecursionforfasterruntimesandasmallerfootprint\">Leverage tail recursion for faster runtimes and a smaller footprint</h1>\n<p>Recursion is a programming concept you probably already know from studying data structures and algorithms. It's a highly readable, easily understandable way of writing methods that involves a call to itself within its definition. However, iterative code that utilizes loops and shared memory is often more efficient in both memory and CPU usage. As StackOverflow user <a href=\"https://stackoverflow.com/users/3267/leigh-caldwell\">Leigh Caldwell</a> puts it,</p>\n<blockquote>\n  <p>Loops may achieve a performance gain for your program. Recursion may achieve a performance gain for your programmer. Choose which is more important in your situation!</p>\n</blockquote>\n<p>Fortunately, a method of programming called <strong>tail recursion</strong> combines these concepts to drastically improve the efficiency of your code while remaining easily readable and maintainable. Let's dive into tail recursion, more about what it is, how to use it, and why you should be using it over traditional recursion.</p>\n<h2 id=\"sowhatistailrecursion\">So what is tail recursion?</h2>\n<p>A tail recursive function is one where the recursive function call is the last operation it executes. Let's look at a classic recursive problem: finding the sum of a list of numbers.</p>\n<p>First, let's look at how you might intuitively solve this problem using traditional recursion:</p>\n<h3 id=\"traditionalrecursion\">Traditional Recursion</h3>\n<pre><code class=\"python language-python\">def sum(array):\n    if array == []:\n    return 0\n    else:\n    return array[0] + sum(array[1:])\n</code></pre>\n<p>Consider how the computer executes this code when the function call is <code>sum([1, 2, 3, 4, 5])</code>:</p>\n<pre><code class=\"python language-python\">sum([1, 2, 3, 4, 5])\n1 + sum([2, 3, 4, 5])\n1 + 2 + sum([3, 4, 5])\n1 + 2 + 3 + sum([4, 5])\n1 + 2 + 3 + 4 + sum([5])\n1 + 2 + 3 + 4 + 5 + sum([])\n1 + 2 + 3 + 4 + 5 + 0\n1 + 2 + 3 + 4 + 5\n1 + 2 + 3 + 9\n1 + 2 + 12\n1 + 14\n15\n</code></pre>\n<p>That was a lot of work to get our answer! Notice how the computer didn't start computing our sum until every recursive call was completed? That's not ideal. Let's take a look at how tail recursion can fix that problem:</p>\n<h3 id=\"tailreucrsionthebetterapproach\">Tail Reucrsion: The Better Approach</h3>\n<pre><code class=\"python language-python\"># runningSum defaults to 0 if only one argument is given\ndef sum(array, runningSum = 0):\n    if array == []:\n    return runningSum\n    else:\n    return sum(array[1:], runningSum + array[0])\n</code></pre>\n<p>Here, our execution trace looks more like this:</p>\n<pre><code class=\"python language-python\">sum([1, 2, 3, 4, 5])\nsum([2, 3, 4, 5], 1)\nsum([3, 4, 5], 3)\nsum([4, 5], 6)\nsum([5], 10)\nsum([], 15)\n15\n</code></pre>\n<p>A lot smaller, right? Our computer will think so too, consuming much less memory and performing the computations as we recurse rather than all at once at the end. When working with large datasets, this approach can save you a lot of runtime and stay within reasonable bounds for memory usage.</p>\n<h2 id=\"howtoconvertarecursivefunctiontotailrecursion\">How to convert a recursive function to tail recursion?</h2>\n<p>Now that you're sold, you can convert a recursive function to tail recursion in one of two ways. The most common method is to use an <strong>accumulator,</strong> like our <code>runningSum</code> from the previous example. Alternatively, you can use a technique called <strong>continuation-passing style</strong> which we'll explore in a moment.</p>\n<h3 id=\"usingaccumulators\">Using Accumulators</h3>\n<p>An accumulator is a variable that keeps track of the intermediate result of the computation. Instead of returning the result of each recursive call, we pass the accumulated result as an argument to the next call.</p>\n<p>For example, consider the following recursive function to calculate the factorial of a number:</p>\n<pre><code class=\"python language-python\">def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n</code></pre>\n<p>We can convert this function to tail-recursive by using an accumulator, called <code>acc</code> in this case:</p>\n<pre><code class=\"python language-python\">def factorial(n, acc=1):\n    if n == 0:\n        return acc\n    else:\n        return factorial(n - 1, n * acc)\n</code></pre>\n<p>Here, our argument <code>acc</code> keeps track of the intermediate result. In each recursive call, we multiply <code>n</code> by <code>acc</code> and pass it as the new value of <code>acc</code>. The final result is returned when n becomes 0, and we have nothing left to recurse on. In this way, computations are performed each time we call the function, rather than delaying, and memory usage is kept constant.</p>\n<h3 id=\"usingcpscontinuationpassingstyle\">Using CPS (Continuation-Passing Style)</h3>\n<p>An alternative method to convert a recursive function to tail-recursive is by\nusing Continuation-Passing Style (CPS). Here, instead of returning the\nresult of a function, we pass a \"continuation function\" as an argument, which is a function that represents the rest of the\ncomputation that needs to be performed with the result of the current\nfunction.</p>\n<p>Consider our factorial example once more:</p>\n<pre><code class=\"python language-python\">def factorial_cps(n, cont):\n    if n == 0:\n        return cont(1)\n    else:\n        return factorial_cps(n - 1, lambda res: cont(n * res))\n</code></pre>\n<p>Here, we added an extra argument <code>cont</code>, our continuation function. In each recursive call, we pass into it a lambda function that multiplies n with the result obtained from the previous call. The final result is obtained by calling the continuation function with the accumulated value of the multiplication.</p>\n<h3 id=\"whichtouse\">Which to use?</h3>\n<p>As with everything nice like this, there's not a clear answer. Some problems may not work using an accumulator variable, whereas others will. Ultimately, when possible, an accumulator is <em>preferred</em> because it's easier to read and implement. But, when the problem requires (example: depth of a binary tree) don't be afraid to implement a continuation-passing style function callback that gets the job done efficiently.</p>\n<h2 id=\"thanksforreading\">Thanks for Reading!</h2>\n<p>If you enjoyed this write-up, you'll love everything else we offer over at <a href=\"https://devbranch.co\">devbranch.co</a>! We cover more awesome topics like this one, we have a <a href=\"https://devbranch.co/newsletter\">newsletter</a> to keep you constantly informed, and we regularly post exclusive discounts on things like hosting, domain names, and tech.</p>\n<h3 id=\"contacttheauthor\">Contact the Author</h3>\n<p><a href=\"https://twitter.com/peterauscher\"><img src=\"https://img.shields.io/badge/Twitter-%231DA1F2.svg?style=for-the-badge&logo=Twitter&logoColor=white\" alt=\"Twitter\" /></a>\n<a href=\"https://github.com/peterrauscher\"><img src=\"https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white\" alt=\"GitHub\" /></a>\n<a href=\"https://www.linkedin.com/in/peter-rauscher\"><img src=\"https://img.shields.io/badge/linkedin-%230077B5.svg?style=for-the-badge&logo=linkedin&logoColor=white\" alt=\"LinkedIn\" /></a>\n<a href=\"mailto:peterrauscher@protonmail.com\"><img src=\"https://img.shields.io/badge/ProtonMail-8B89CC?style=for-the-badge&logo=protonmail&logoColor=white\" alt=\"Protonmail\" /></a></p>","data":{"title":"Leveraging tail recursion for faster runtimes and smaller footprints","date":"2022-03-28T00:00:00.000Z","published":true},"isEmpty":false,"excerpt":"","filename":"/Users/peterrauscher/Repositories/peterrauscher.com/posts/tail-recursion.md"}]